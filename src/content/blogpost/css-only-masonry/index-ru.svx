---
title: "Галерея изображений в раскладке Masonry на (почти) чистом CSS"
description: "Реализуем компонент для галереи изображений в стиле раскладки Masonry, используя возможности CSS."
lang: ru
created: 2022-04-27T13:11:00.000Z
updated: 2022-04-27T13:11:00.000Z
keywords: [ "css", "web" ]
published: false
layout: blogpost
---

<script>
  import { Details } from "@components";
  import { GridDense, MasonryDemo, MasonryShift } from "./components";
</script>

Раскладка Masonry, известная под множеством имён: *плиточная вёрстка*, *Cascading Grid*, "раскладка как в Pinterest", является довольно практичным типом раскладки. Своим названием раскладка обязана слову "каменщик", внешне она действительно напоминает укладку каменной стены.

<Details>
  <svelte:fragment slot="title">
    Что такое Masonry?
  </svelte:fragment>

  В раскладке Masonry элементы располагаются друг за другом в строчном направлении. В отличие от привычной табличной раскладки при переносе на новую строку элементы смещаются в вертикальном направлении, заполняя доступное пространство за элементом в предыдущей строке той же колонки.

</Details>

Чтобы лучше представить себе как это выглядит, воспользуемся табличной раскладкой. Заполним её, например, изображениями с разным соотношением сторон или карточками с разным по величине наполнением. В глаза бросаются "обрывы" между элементами одного столбца, обычно принято избавляться от этого недоразумения растяжением по высоте. Правда, факт остаётся фактом - пространство в данном случае используется неэффективно. Одним из возможных решений этого вопроса собственно и является раскладка **Masonry**:

<MasonryShift />

## Текущие возможности и перспективы

Приблизиться к Masonry можно с помощью нескольких способов:

- свойство `column-count`. Правда, приближением подобное решение является из-за наполнения по вертикали. Имеются сложности с отзывчивостью такого решения;
- использование `display: flex` с наполнением по вертикали, но в этот раз уже имеется возможность управления визуальным порядком элементов. Всё также возникают проблемы с отзывчивостью, присутсвуют "магические числа". Узнать более подробно о данном подходе можно [здесь][css-masonry-flex];
- раскладка CSS Grid со свойством `grid-auto-flow: dense` с частичным нарушением визуального порядка, к тому же, такая раскладка всё ещё остается сеткой и сместить элементы по вертикали относительно свободного пространства не является возможным.

Получить настоящую Masonry в будущем можно будет парой способов:

- Используя <abbr title="Cascading Style Sheets">CSS</abbr>, уже сейчас разрабатывается [спецификация][draft], возможно, раскладка станет частью модуля CSS Grid. На момент написания статьи функционал доступен в Firefox Nightly за флагом `layout.css.grid-template-masonry-value.enabled`. Подробнее можно почитать [на MDN][mdn:masonry];
- [CSS Layout API][css-layout-api] позволит писать свои алгоритмы раскладки без серьёзного падения производительности. Ознакомиться с реализацией раскладки Masonry с использованием CSS Layout API можно [тут][css-layout-api-masonry], и даже испробовать [демо][css-layout-api-masonry-demo] на поддерживающих <abbr title="Application Programming Interface">API</abbr> браузерах.

К сожалению, на момент написания статьи вывод неутешителен: для реализации раскладки всё ещё необходимо использовать JavaScript.

## Приближение к Masonry с помощью CSS

Целью данной статьи является демонстрация возможного легковесного приближения к Masonry с помощью средств CSS и лишь капельки JavaScript. Приближением оно будет являться в силу частичного визуального порядка элементов и немного отличной укладки в отличие от истинного Masonry. В случаях, когда порядок действительно имеет значение - данное решение **не имеет практического смысла**. Из преимуществ - относительно простая реализация, высокая производительность и минимально возможное использование JavaScript.

Ниже представлен результат в виде интерактивного демо:

<MasonryDemo />

## Реализация

Фундаментом решения будет уже вышеупомянутое свойство CSS: `grid-auto-flow: dense`, в таком случае CSS Grid по возможности заполняет вакантные ячейки, буквально "упаковывая" сетку. И тем не менее, раскладка всё ещё остаётся сеткой. Для решения этой проблемы воспользуемся охватом - это величина, указывающая количество ячеек, в которые раскладка должна расположить элемент. Например, чтобы расположить элемент вдоль и поперёк на две и три ячейки соответственно:

```css
.grid-item {
  grid-row-end: span 3;
  grid-column-end: span 2;
}
```

Выглядеть такое решение будет следующим образом:

<GridDense items={30} />

Получается, если известны размеры элементов, можно расположить их в сетке в соответствии с соотношением их сторон, в то же время сетка по возможности будет заполнять пробелы. В этом и заключается приближение к раскладке Masonry.

Свойство `grid-auto-flow: dense` пусть и частично, но влияет на визуальный порядок элементов. Расположение в <abbr title="Document Object Model">DOM</abbr> остаётся прежним. Необходимо учесть, важен ли в конкретной задаче визуальный порядок элементов. В противном случае данное решение окажется непрактичным. Приближение будет использоваться для галереи изображений с целью сохранить соотношение сторон и где визуальный порядок не столь важен.

### Стили

Первым делом определим стили. Используем раскладку `grid`, зададим количество столбцов динамически с помощью функции `repeat()` и параметра `auto-fill`. Количество строк определяем аналогичным образом, используя параметр `auto-fit`. В итоге, получаем динамическую  отзывчивую сетку, заполненную околоквадратными ячейками заданного размера. Размер ячеек будет определяться унаследованной переменной `--masonry-scale`, не забываем задать значение по умолчанию:

```css
.masonry {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(var(--masonry-scale, 100px), 1fr));
  grid-template-rows: repeat(auto-fit, var(--masonry-scale, 100px));
  grid-auto-flow: dense;
  grid-gap: 1rem;
}
```

Подробнее об этом приёме можно прочесть [здесь][no-media-css-grid].

Имея в наличии сетку, уложим элементы в заданные ячейки, основываясь на размеры.

### Расчёт охвата

Определим размер охвата и столбцов, задаваемый на основе размера ячеек. Определим функцию `getMasonryItemSpan` для рассчёта величины охвата на его размерах. Переменная `--masonry-scale`, используемая для определения размеров единичной ячейки, используется как параметр `scale` являясь масштабным отрезком:

```ts
const calcMasonryItemSpan = (size, scale) => Math.floor(size / scale);
```

Простыми словами, зная размеры элемента (например, изображения), расчитываем, сколько целых единичных ячеек понадобится для помещения элемента вдоль и поперёк. Полученные данные передаются через кастомные переменные `--masonry-item-row` и `--masonry-item-column` для расположения элементов внутри раскладки:

```css
.masonry > .masonry-item {
  grid-row-end: span var(--masonry-item-row);
  grid-column-end: span var(--masonry-item-column); 
}
```

### Результат

Соберём картину воедино:

1. Компонент получает на вход данные о размерах каждого элемента и масштабный размер ячеек;
2. Размер ячеек передаётся в стили через переменную `--masonry-scale`;
2. Основываясь на размерах, для каждого элемента расчитывается охват по вертикали и горизонтали, данные передаются через переменные `--masonry-item-row` и `--masonry-item-column` соответственно;

Итого, пример базового компонента на [Svelte][svelte] будет выглядеть так:

```svelte
<script context="module">
  const calcMasonryItemSpan = (size, scale) => Math.floor(size / scale);
</script>

<script>
  export let scale = 100;
  export let items = [];
</script>

<ul class="masonry" style:--masonry-scale="{scale}px">
  {#each items as { height, width }}
    <li
      class="item"
      style:--masonry-item-row={getMasonryItemSpan(height, scale)}
      style:--masonry-item-column={getMasonryItemSpan(width, scale)}
    >
      <slot />
    </li>
  {/each}
</ul>

<style>
  .masonry {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--masonry-scale, 100px), 1fr));
    grid-template-rows: repeat(auto-fit, var(--masonry-scale, 100px));
    grid-auto-flow: dense;
    grid-gap: 1rem;
  }

  .masonry > .item {
    grid-row-end: span var(--masonry-item-row);
    grid-column-end: span var(--masonry-item-column); 
  }
</style>
```

## Выводы

Пример использования данной идеи можно увидеть на [в разделе галереи](/ru/gallery), по умолчанию раскладка отключена, не забудьте воспользоваться переключателем.

Сложно назвать это приближение действительно достойной заменой полноценной раскладки Masonry. Нарушение порядка элементом остаётся серьёзной проблемой, на фоне аналогичных решений приближение не выигрывает. Так же, в отличие от истинной раскадки в зависимости от разрозненности размеров элементов, в сетке могут иметься пустоты.

Из преимуществ важно подчекрнуть приятную отзывчивость разметки без использования медиа выражений, "магических чисел" и отличную производительность. Идея хорошо показала себя при использовании разметки фотогалереи, изображения сохраняют свои пропорции, эффективно заполняя доступное пространство. 

## Ссылки

- [CSS Layout API][css-layout-api]
- [How to make a dynamic interlocking image grid with CSS](https://www.samdawson.dev/article/auto-flow-dense-varying-image-sizes)
- [Look Ma, No Media Queries! Responsive Layouts Using CSS Grid][no-media-css-grid]
- [MDN: CSS Grid Masonry Layout][mdn:masonry]
- [Native CSS Masonry Layout In CSS Grid](https://www.smashingmagazine.com/native-css-masonry-layout-css-grid/)
- [Нативный Masonry Layout в CSS Grid Level 3](https://habr.com/ru/post/526008/)
- [Спецификация CSS Grid Masonry Layout][draft]

<!-- Reference Links -->

[css-layout-api]: https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
[css-layout-api-masonry]: https://github.com/GoogleChromeLabs/houdini-samples/tree/master/layout-worklet/masonry
[css-layout-api-masonry-demo]: https://css-houdini.rocks/masonry
[css-masonry-flex]: https://tobiasahlin.com/blog/masonry-with-css/
[draft]: https://drafts.csswg.org/css-grid-3/#masonry-layout
[mdn:masonry]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Masonry_Layout
[no-media-css-grid]: https://css-tricks.com/look-ma-no-media-queries-responsive-layouts-using-css-grid/
[svelte]: https://svelte.dev/
