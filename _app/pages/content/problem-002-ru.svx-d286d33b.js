import{S as n,i as a,s,B as t,j as e,m as p,o,p as c,q as r,x as i,u as l,v as u,X as k,e as f,t as m,k as $,c as h,a as _,g,d as b,n as d,b as F,f as v,E,R as w}from"../../chunks/vendor-c811b0ff.js";import{B as y,M as P}from"../../chunks/Math-c2097aab.js";import"../../chunks/theme-a188ce45.js";function q(n){let a,s,t,c,r,k,y,q,O,S,T,H,R,j,x,C,D,M,B,G,N,L,Z,X,z,A,I,J,K,Q,U,V,W,Y,nn,an,sn,tn,en,pn,on,cn,rn,ln,un,kn,fn,mn,$n,hn,_n,gn,bn,dn,Fn,vn,En,wn,yn,Pn,qn,On,Sn,Tn,Hn,Rn,jn,xn,Cn,Dn,Mn,Bn,Gn,Nn,Ln,Zn,Xn,zn,An,In,Jn,Kn,Qn,Un,Vn,Wn,Yn,na,aa,sa,ta,ea,pa,oa,ca,ra,ia,la,ua,ka,fa,ma;return y=new P({props:{math:String.raw`1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...`}}),Tn=new P({props:{inline:!0,math:"F(n)"}}),Rn=new P({props:{inline:!0,math:"F(n - 3)"}}),xn=new P({props:{inline:!0,math:"F(n - 6)"}}),Gn=new P({props:{inline:!0,math:n[0]}}),Zn=new P({props:{math:n[1]}}),Jn=new P({props:{math:n[2]}}),{c(){a=f("h1"),s=m("Проблема №2: Чётные числа Фибоначчи"),t=$(),c=f("p"),r=m("Каждый новый член последовательности Фибоначчи получается из суммы двух предыдущих. Начиная с 1 и 2, первые 10 членов последовательности будут:"),k=$(),e(y.$$.fragment),q=$(),O=f("p"),S=m("Найти сумму всех чётных членов последовательности, значения которых не превышают четыре миллиона."),T=$(),H=f("h2"),R=m("Brute-force решение"),j=$(),x=f("p"),C=m("Для начала отбросим тонкости и попробуем решить задачу максимально просто. Так как нам нужно сумму членов последовательности, удовлетворяющих некоторому условию, то необходимо сгенерировать саму последовательность."),D=$(),M=f("h3"),B=m("Пример реализации на Python"),G=$(),N=f("p"),L=m("В реализации решения с помощью "),Z=f("em"),X=m("Python"),z=m(", воспользуемся генератором. Для этого определим функцию-генератор "),A=f("code"),I=m("fibonacci_sequence"),J=m(", единственным параметром которой будет максимальное значение члена последовательности."),K=$(),Q=f("p"),U=m("Далее, уже непосредственно для решения задачи определим функцию "),V=f("code"),W=m("even_fib_sum"),Y=m(", в которой с помощью "),nn=f("code"),an=m("list comprehension"),sn=m(" найдём сумму всех чётных значений генератора, не привышающих максимальное значение, переданное в единственный параметр функции."),tn=$(),en=f("pre"),pn=$(),on=f("h2"),cn=m("Чётная последовательность Фибоначчи"),rn=$(),ln=f("p"),un=m("Основная проблема предыдущего решения в том, что мы генерировали все значения последовательности, хотя для решения достаточно лишь чётных по значению. Попробуем взглянуть на чётные члены последовательности:"),kn=$(),fn=f("p"),mn=m("0, 1, 1, "),$n=f("strong"),hn=m("2"),_n=m(", 3, 5, "),gn=f("strong"),bn=m("8"),dn=m(", 13, 21, "),Fn=f("strong"),vn=m("34"),En=m(", 55, 89, "),wn=f("strong"),yn=m("144"),Pn=m(", …"),qn=$(),On=f("p"),Sn=m("Не забывая, что счёт индексов начинется с нуля, заметим, что все чётные элементы повторяются с постоянным интервалом, каждое третье число Фибоначчи чётное. Выходит, что можно попробовать выразить закономерность для генерации лишь чётных числе Фибоначчи, используя реккурентную формулу. Для этого необходимо выразить "),e(Tn.$$.fragment),Hn=m(" через "),e(Rn.$$.fragment),jn=m(" и "),e(xn.$$.fragment),Cn=m("."),Dn=$(),Mn=f("p"),Bn=m("Используя определение последовательности Фибоначчи "),e(Gn.$$.fragment),Nn=m(" представим себе матрёшку, где каждый член последовательности мы можем раскрыть через сумму двух предыдущих. Совершим серию преобразований:"),Ln=$(),e(Zn.$$.fragment),Xn=$(),zn=f("p"),An=m("Итого, мы получили реккурентное выражение исключительно для чётных элементов последовательности Фибоначчи:"),In=$(),e(Jn.$$.fragment),Kn=$(),Qn=f("p"),Un=m("Больше нет необходимости в проверке чётности значений, код становится проще и быстрее."),Vn=$(),Wn=f("h3"),Yn=m("Пример реализации на Python"),na=$(),aa=f("p"),sa=m("Аналогично предыдущему решению, используем генератор для получения последовательности Фибоначчи "),ta=f("code"),ea=m("fibonacci_sequence_even"),pa=m(". В этот раз он будет генерировать лишь чётные значения последовательности, поэтому впишем вместо 0 и 1: 2 и 8, как первые четные элементы и используем реккурентное соотношение, полученое в разборе выше."),oa=$(),ca=f("p"),ra=m("Для решения задачи снова определяем функцию "),ia=f("code"),la=m("even_fib_sum"),ua=m(", суммируя значения генератора, с тем отличием, что больше нет необходимости в проверке чётности."),ka=$(),fa=f("pre"),this.h()},l(n){a=h(n,"H1",{});var e=_(a);s=g(e,"Проблема №2: Чётные числа Фибоначчи"),e.forEach(b),t=d(n),c=h(n,"P",{});var o=_(c);r=g(o,"Каждый новый член последовательности Фибоначчи получается из суммы двух предыдущих. Начиная с 1 и 2, первые 10 членов последовательности будут:"),o.forEach(b),k=d(n),p(y.$$.fragment,n),q=d(n),O=h(n,"P",{});var i=_(O);S=g(i,"Найти сумму всех чётных членов последовательности, значения которых не превышают четыре миллиона."),i.forEach(b),T=d(n),H=h(n,"H2",{});var l=_(H);R=g(l,"Brute-force решение"),l.forEach(b),j=d(n),x=h(n,"P",{});var u=_(x);C=g(u,"Для начала отбросим тонкости и попробуем решить задачу максимально просто. Так как нам нужно сумму членов последовательности, удовлетворяющих некоторому условию, то необходимо сгенерировать саму последовательность."),u.forEach(b),D=d(n),M=h(n,"H3",{});var f=_(M);B=g(f,"Пример реализации на Python"),f.forEach(b),G=d(n),N=h(n,"P",{});var m=_(N);L=g(m,"В реализации решения с помощью "),Z=h(m,"EM",{});var $=_(Z);X=g($,"Python"),$.forEach(b),z=g(m,", воспользуемся генератором. Для этого определим функцию-генератор "),A=h(m,"CODE",{});var F=_(A);I=g(F,"fibonacci_sequence"),F.forEach(b),J=g(m,", единственным параметром которой будет максимальное значение члена последовательности."),m.forEach(b),K=d(n),Q=h(n,"P",{});var v=_(Q);U=g(v,"Далее, уже непосредственно для решения задачи определим функцию "),V=h(v,"CODE",{});var E=_(V);W=g(E,"even_fib_sum"),E.forEach(b),Y=g(v,", в которой с помощью "),nn=h(v,"CODE",{});var w=_(nn);an=g(w,"list comprehension"),w.forEach(b),sn=g(v," найдём сумму всех чётных значений генератора, не привышающих максимальное значение, переданное в единственный параметр функции."),v.forEach(b),tn=d(n),en=h(n,"PRE",{class:!0}),_(en).forEach(b),pn=d(n),on=h(n,"H2",{});var P=_(on);cn=g(P,"Чётная последовательность Фибоначчи"),P.forEach(b),rn=d(n),ln=h(n,"P",{});var ma=_(ln);un=g(ma,"Основная проблема предыдущего решения в том, что мы генерировали все значения последовательности, хотя для решения достаточно лишь чётных по значению. Попробуем взглянуть на чётные члены последовательности:"),ma.forEach(b),kn=d(n),fn=h(n,"P",{});var $a=_(fn);mn=g($a,"0, 1, 1, "),$n=h($a,"STRONG",{});var ha=_($n);hn=g(ha,"2"),ha.forEach(b),_n=g($a,", 3, 5, "),gn=h($a,"STRONG",{});var _a=_(gn);bn=g(_a,"8"),_a.forEach(b),dn=g($a,", 13, 21, "),Fn=h($a,"STRONG",{});var ga=_(Fn);vn=g(ga,"34"),ga.forEach(b),En=g($a,", 55, 89, "),wn=h($a,"STRONG",{});var ba=_(wn);yn=g(ba,"144"),ba.forEach(b),Pn=g($a,", …"),$a.forEach(b),qn=d(n),On=h(n,"P",{});var da=_(On);Sn=g(da,"Не забывая, что счёт индексов начинется с нуля, заметим, что все чётные элементы повторяются с постоянным интервалом, каждое третье число Фибоначчи чётное. Выходит, что можно попробовать выразить закономерность для генерации лишь чётных числе Фибоначчи, используя реккурентную формулу. Для этого необходимо выразить "),p(Tn.$$.fragment,da),Hn=g(da," через "),p(Rn.$$.fragment,da),jn=g(da," и "),p(xn.$$.fragment,da),Cn=g(da,"."),da.forEach(b),Dn=d(n),Mn=h(n,"P",{});var Fa=_(Mn);Bn=g(Fa,"Используя определение последовательности Фибоначчи "),p(Gn.$$.fragment,Fa),Nn=g(Fa," представим себе матрёшку, где каждый член последовательности мы можем раскрыть через сумму двух предыдущих. Совершим серию преобразований:"),Fa.forEach(b),Ln=d(n),p(Zn.$$.fragment,n),Xn=d(n),zn=h(n,"P",{});var va=_(zn);An=g(va,"Итого, мы получили реккурентное выражение исключительно для чётных элементов последовательности Фибоначчи:"),va.forEach(b),In=d(n),p(Jn.$$.fragment,n),Kn=d(n),Qn=h(n,"P",{});var Ea=_(Qn);Un=g(Ea,"Больше нет необходимости в проверке чётности значений, код становится проще и быстрее."),Ea.forEach(b),Vn=d(n),Wn=h(n,"H3",{});var wa=_(Wn);Yn=g(wa,"Пример реализации на Python"),wa.forEach(b),na=d(n),aa=h(n,"P",{});var ya=_(aa);sa=g(ya,"Аналогично предыдущему решению, используем генератор для получения последовательности Фибоначчи "),ta=h(ya,"CODE",{});var Pa=_(ta);ea=g(Pa,"fibonacci_sequence_even"),Pa.forEach(b),pa=g(ya,". В этот раз он будет генерировать лишь чётные значения последовательности, поэтому впишем вместо 0 и 1: 2 и 8, как первые четные элементы и используем реккурентное соотношение, полученое в разборе выше."),ya.forEach(b),oa=d(n),ca=h(n,"P",{});var qa=_(ca);ra=g(qa,"Для решения задачи снова определяем функцию "),ia=h(qa,"CODE",{});var Oa=_(ia);la=g(Oa,"even_fib_sum"),Oa.forEach(b),ua=g(qa,", суммируя значения генератора, с тем отличием, что больше нет необходимости в проверке чётности."),qa.forEach(b),ka=d(n),fa=h(n,"PRE",{class:!0}),_(fa).forEach(b),this.h()},h(){F(en,"class","language-python"),F(fa,"class","language-python")},m(n,e){v(n,a,e),E(a,s),v(n,t,e),v(n,c,e),E(c,r),v(n,k,e),o(y,n,e),v(n,q,e),v(n,O,e),E(O,S),v(n,T,e),v(n,H,e),E(H,R),v(n,j,e),v(n,x,e),E(x,C),v(n,D,e),v(n,M,e),E(M,B),v(n,G,e),v(n,N,e),E(N,L),E(N,Z),E(Z,X),E(N,z),E(N,A),E(A,I),E(N,J),v(n,K,e),v(n,Q,e),E(Q,U),E(Q,V),E(V,W),E(Q,Y),E(Q,nn),E(nn,an),E(Q,sn),v(n,tn,e),v(n,en,e),en.innerHTML='<code class="language-python"><span class="token keyword">def</span> <span class="token function">fibonacci_sequence</span><span class="token punctuation">(</span>limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>\n  a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>\n  <span class="token keyword">while</span> a <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>\n    <span class="token keyword">yield</span> a\n    a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b\n    \n<span class="token keyword">def</span> <span class="token function">even_fib_sum</span><span class="token punctuation">(</span>limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>\n  <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span> item <span class="token keyword">for</span> item <span class="token keyword">in</span> fibonacci_sequence<span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token keyword">if</span> item <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">)</span></code>',v(n,pn,e),v(n,on,e),E(on,cn),v(n,rn,e),v(n,ln,e),E(ln,un),v(n,kn,e),v(n,fn,e),E(fn,mn),E(fn,$n),E($n,hn),E(fn,_n),E(fn,gn),E(gn,bn),E(fn,dn),E(fn,Fn),E(Fn,vn),E(fn,En),E(fn,wn),E(wn,yn),E(fn,Pn),v(n,qn,e),v(n,On,e),E(On,Sn),o(Tn,On,null),E(On,Hn),o(Rn,On,null),E(On,jn),o(xn,On,null),E(On,Cn),v(n,Dn,e),v(n,Mn,e),E(Mn,Bn),o(Gn,Mn,null),E(Mn,Nn),v(n,Ln,e),o(Zn,n,e),v(n,Xn,e),v(n,zn,e),E(zn,An),v(n,In,e),o(Jn,n,e),v(n,Kn,e),v(n,Qn,e),E(Qn,Un),v(n,Vn,e),v(n,Wn,e),E(Wn,Yn),v(n,na,e),v(n,aa,e),E(aa,sa),E(aa,ta),E(ta,ea),E(aa,pa),v(n,oa,e),v(n,ca,e),E(ca,ra),E(ca,ia),E(ia,la),E(ca,ua),v(n,ka,e),v(n,fa,e),fa.innerHTML='<code class="language-python"><span class="token keyword">def</span> <span class="token function">fibonacci_sequence_even</span><span class="token punctuation">(</span>limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>\n  a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span>\n  <span class="token keyword">while</span> a <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>\n    <span class="token keyword">yield</span> a\n    a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> b <span class="token operator">+</span> a\n    \n<span class="token keyword">def</span> <span class="token function">even_fib_sum</span><span class="token punctuation">(</span>limit<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>\n  <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">[</span> item <span class="token keyword">for</span> item <span class="token keyword">in</span> fibonacci_sequence_even<span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">)</span></code>',ma=!0},p:w,i(n){ma||(i(y.$$.fragment,n),i(Tn.$$.fragment,n),i(Rn.$$.fragment,n),i(xn.$$.fragment,n),i(Gn.$$.fragment,n),i(Zn.$$.fragment,n),i(Jn.$$.fragment,n),ma=!0)},o(n){l(y.$$.fragment,n),l(Tn.$$.fragment,n),l(Rn.$$.fragment,n),l(xn.$$.fragment,n),l(Gn.$$.fragment,n),l(Zn.$$.fragment,n),l(Jn.$$.fragment,n),ma=!1},d(n){n&&b(a),n&&b(t),n&&b(c),n&&b(k),u(y,n),n&&b(q),n&&b(O),n&&b(T),n&&b(H),n&&b(j),n&&b(x),n&&b(D),n&&b(M),n&&b(G),n&&b(N),n&&b(K),n&&b(Q),n&&b(tn),n&&b(en),n&&b(pn),n&&b(on),n&&b(rn),n&&b(ln),n&&b(kn),n&&b(fn),n&&b(qn),n&&b(On),u(Tn),u(Rn),u(xn),n&&b(Dn),n&&b(Mn),u(Gn),n&&b(Ln),u(Zn,n),n&&b(Xn),n&&b(zn),n&&b(In),u(Jn,n),n&&b(Kn),n&&b(Qn),n&&b(Vn),n&&b(Wn),n&&b(na),n&&b(aa),n&&b(oa),n&&b(ca),n&&b(ka),n&&b(fa)}}}function O(n){let a,s;const k=[n[3],S];let f={$$slots:{default:[q]},$$scope:{ctx:n}};for(let e=0;e<k.length;e+=1)f=t(f,k[e]);return a=new y({props:f}),{c(){e(a.$$.fragment)},l(n){p(a.$$.fragment,n)},m(n,t){o(a,n,t),s=!0},p(n,[s]){const t=8&s?c(k,[8&s&&r(n[3]),0&s&&r(S)]):{};16&s&&(t.$$scope={dirty:s,ctx:n}),a.$set(t)},i(n){s||(i(a.$$.fragment,n),s=!0)},o(n){l(a.$$.fragment,n),s=!1},d(n){u(a,n)}}}const S={title:"Проект Эйлера #2: Чётные числа Фибоначчи",series:"Проект Эйлера",lang:"ru",created:"2021-06-11T00:00:00.000Z",updated:"2021-06-13T00:00:00.000Z",slug:"project-euler-002-ru",layout:"blogpost"};function T(n,a,s){const e=String.raw`F_{n} = F_{n-1} + F_{n-2}`,p=String.raw`
		\begin{aligned}
			F_{n} &= F_{n-1} + F_{n-2}\\
			&= F_{n-2} + F_{n-3} + F_{n-2}\\
			&= 2  \times F_{n-2} + F_{n-3}\\
			&= 2 \times (F_{n-3} + F_{n-4}) + F_{n-3}\\
			&= 2 \times F_{n-3} + 2 \times F_{n-4} + F_{n-3}\\
			&= 3 \times F_{n-3} + 2 \times F_{n-4}\\
			&= 3 \times F_{n-3} + F_{n-4} + F_{n-4}\\
			&= 3 \times F_{n-3} + F_{n-4} + F_{n-5} + F_{n-6}\\
			&= 3 \times F_{n-3} + (F_{n-4} + F_{n-5}) + F_{n-6}\\
			&= 3 \times F_{n-3} + F_{n-3} + F_{n-6}\\
			&= 4 \times F_{n-3} + F_{n-6}\\
		\end{aligned}
	`,o=String.raw`F_{n} = 4 \times F_{n-3} + F_{n-6}`;return n.$$set=n=>{s(3,a=t(t({},a),k(n)))},[e,p,o,a=k(a)]}class H extends n{constructor(n){super(),a(this,n,T,O,s,{})}}export{H as default,S as metadata};
